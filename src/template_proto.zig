const std = @import("std");
const builtin = @import("builtin");
const mustache = @import("vendors/mustache-zig/src/mustache.zig");

pub fn get_template() []const u8 {
    const template =
        \\# Autogenerated Python bindings for {{struct_ident}}
        \\# Do not edit this file directly
        \\
        \\from ctypes import CDLL, Structure, POINTER{{#ctype_imports}}, {{ident}}{{/ctype_imports}}
        \\
        \\libzigpy = CDLL("./zig-out/lib/libzigpy.{{shared_lib_extension}}")
        \\
        \\# Public class
        \\class {{struct_ident}}(Structure):
        \\    _fields_ = [{{#fields}}("{{ident}}", {{ctype}}), {{/fields}}]
        \\
        \\# Shared Library Function interfaces
        \\{{#methods}}
        \\libzigpy.{{libzigpy_ident}}.argtypes = [{{#args}}{{ctype}}, {{/args}}]
        \\
        \\{{/methods}}
    ;
    return template;
}

const Field = struct {
    ident: []const u8,
    ctype: []const u8,
};

const CTypeImport = struct {
    ident: []const u8,
};

const ZigType = union(enum) {
    i32,
    bool,
    zero_terminated_u8_slice,

    fn fromType(comptime T: type) ZigType {
        switch (T) {
            i32 => return .i32,
            bool => return .bool,
            [*:0]u8 => return .zero_terminated_u8_slice,
            else => @compileError("unsupported type"),
        }
    }

    fn toCType(self: ZigType) []const u8 {
        return switch (self) {
            .i32 => "c_int",
            .bool => "c_int",
            .zero_terminated_u8_slice => "c_char_p",
        };
    }

    fn toPyType(self: ZigType) []const u8 {
        return switch (self) {
            .i32 => "int",
            .bool => "bool",
            .zero_terminated_u8_slice => "str",
        };
    }
};

const Arg = struct {
    zig_type: ZigType,
    ident: []const u8,
};

pub const Method = struct {
    alloc: std.mem.Allocator,
    libzigpy_ident: []const u8,
    argsList: std.ArrayList(Arg),
    args: []Arg, // for rendering

    pub fn init(alloc: std.mem.Allocator, libzigpy_ident: []const u8) Method {
        var self = Method{
            .alloc = alloc,
            .libzigpy_ident = libzigpy_ident,
            .argsList = std.ArrayList(Arg).init(alloc),
            .args = undefined,
        };
        self.args = self.argsList.items;
        return self;
    }
    pub fn addArg(self: *Method, comptime zig_type: type, ident: []const u8) !void {
        try self.argsList.append(.{
            .zig_type = ZigType.fromType(zig_type),
            .ident = ident,
        });
        self.args = self.argsList.items;
    }
};

pub const TemplateData = struct {
    alloc: std.mem.Allocator,
    struct_ident: []const u8,
    shared_lib_extension: []const u8,
    fields: std.ArrayList(Field),
    ctype_imports: std.ArrayList(CTypeImport),
    methods: std.ArrayList(Method),

    pub fn init(alloc: std.mem.Allocator, struct_ident: []const u8) TemplateData {
        const fields = std.ArrayList(Field).init(alloc);
        const ctype_imports = std.ArrayList(CTypeImport).init(alloc);
        const methods = std.ArrayList(Method).init(alloc);

        const shared_lib_extension = switch (builtin.os.tag) {
            .macos => "dylib",
            .linux => "so",
            else => @compileError("unsupported os"),
        };

        return TemplateData{
            .alloc = alloc,
            .struct_ident = struct_ident,
            .shared_lib_extension = shared_lib_extension,
            .fields = fields,
            .ctype_imports = ctype_imports,
            .methods = methods,
        };
    }

    pub fn addField(
        self: *TemplateData,
        ident: []const u8,
        ctype: []const u8,
    ) !void {
        try self.fields.append(.{
            .ident = ident,
            .ctype = ctype,
        });

        try self.assureCTypeImport(ctype);
    }

    pub fn addMethod(self: *TemplateData, method: *Method) !void {
        try self.methods.append(method.*);
    }

    fn assureCTypeImport(self: *TemplateData, ctype: []const u8) !void {
        var is_imported = false;
        for (self.ctype_imports.items) |c_type_import| {
            if (std.mem.eql(u8, c_type_import.ident, ctype)) {
                is_imported = true;
                break;
            }
        }
        if (!is_imported) {
            try self.ctype_imports.append(.{ .ident = ctype });
        }
    }

    pub fn render(self: *TemplateData) ![]const u8 {
        const template = get_template();
        const data = .{
            .struct_ident = self.struct_ident,
            .shared_lib_extension = self.shared_lib_extension,
            .fields = self.fields.items,
            .ctype_imports = self.ctype_imports.items,
            .methods = self.methods.items,
        };
        return try mustache.allocRenderText(self.alloc, template, data);
    }
};
