const std = @import("std");
const builtin = @import("builtin");
const mustache = @import("vendors/mustache-zig/src/mustache.zig");

// users should import their own library
// todo: autodetect this or do something tricky in build.zig
const targetStruct = @import("./example_lib.zig").MyStruct;

pub fn main() !void {
    comptime var split_itr = std.mem.splitBackwardsAny(u8, @typeName(targetStruct), ".");
    const struct_name = comptime split_itr.first();

    const shared_lib_extension = switch (builtin.os.tag) {
        .macos => "dylib",
        .linux => "so",
        else => @compileError("unsupported os"),
    };

    const template =
        \\# Autogenerated Python bindings for {{struct_name}}
        \\# Do not edit this file directly
        \\
        \\from ctypes import CDLL, Structure, c_int, POINTER
        \\
        \\libzigpy = CDLL("./zig-out/lib/libzigpy.{{shared_lib_extension}}")
        \\
        \\class {{struct_name}}(Structure):
        \\    _fields_ = [{{#field_data}}("{{name}}", {{type}}), {{/field_data}}]
        \\
        \\libzigpy.{{init}}.restype = POINTER({{struct_name}})
        \\libzigpy.{{del}}.argtypes = [POINTER({{struct_name}})]
        \\
        \\class {{struct_name}}():
        \\  def __init__(self):
        \\    self.ptr = libzigpy.{{init}}()
        \\
        \\  def __del__(self):
        \\    libzigpy.{{del}}(self.ptr)
        \\
        \\
        \\  {{#properties}}
        \\  @property
        \\  def {{name}}(self):
        \\      return self.ptr.contents.{{name}}
        \\
        \\  @{{name}}.setter
        \\  def {{name}}(self, value):
        \\      self.ptr.contents.{{name}} = value
        \\
        \\
        \\  {{/properties}}
        \\  {{#methods}}
        \\  def {{pyname}}(self): 
        \\      return libzigpy.{{zigname}}(self.ptr)
        \\
        \\
        \\  {{/methods}}
    ;

    // assumptions
    // all pub structs are also "extern"
    // all relevant methods are "pub export" and within the namespace of the struct

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const alloc = arena.allocator();
    defer arena.deinit();

    const info = @typeInfo(targetStruct); // todo: make CodeGenStruct dynamic and "addlib" dynamic
    switch (info) {
        .Struct => |struct_info| {
            const Field = struct {
                name: []const u8,
                type: []const u8,
            };
            var field_data = std.ArrayList(Field).init(alloc);
            const Property = struct {
                name: []const u8,
            };
            var properties = std.ArrayList(Property).init(alloc);
            inline for (struct_info.fields) |field| {
                try field_data.append(.{ .name = field.name, .type = "c_int" }); // todo: make type dynamic
                try properties.append(.{ .name = field.name });
            }
            var init_data = std.ArrayList(u8).init(alloc);
            var del_data = std.ArrayList(u8).init(alloc);
            const Method = struct {
                pyname: []const u8,
                zigname: []const u8,
            };
            var methods = std.ArrayList(Method).init(alloc);
            inline for (struct_info.decls) |decl| {
                if (std.mem.eql(u8, decl.name, "__init__")) {
                    try init_data.appendSlice("codegenstruct_" ++ decl.name); // todo: make lowercasing of codegenstruct dynamic
                } else if (std.mem.eql(u8, decl.name, "__del__")) {
                    try del_data.appendSlice("codegenstruct_" ++ decl.name);
                } else {
                    const zigname = "codegenstruct_" ++ decl.name; // in the shared library we prefix with the struct name to avoid collisions
                    try methods.append(.{ .pyname = decl.name, .zigname = zigname });
                }
            }
            const data = .{
                .struct_name = struct_name,
                .field_data = field_data.items,
                .properties = properties.items,
                .init = init_data.items,
                .del = del_data.items,
                .methods = methods.items,
                .shared_lib_extension = shared_lib_extension,
            };
            const result = try mustache.allocRenderText(alloc, template, data);

            const output_file_path = struct_name ++ ".py";
            var output_file = std.fs.cwd().createFile(output_file_path, .{}) catch unreachable;
            defer output_file.close();
            try output_file.writeAll(result);
        },

        else => unreachable,
    }

    return std.process.cleanExit();
}

/// For use by users to flag their structs for export
pub fn exportStruct(comptime zig_struct: type) void {
    const info = @typeInfo(zig_struct);
    switch (info) {
        .Struct => |struct_info| {
            inline for (struct_info.decls) |decl| {
                if (std.mem.eql(u8, decl.name, "__init__")) {
                    @export(zig_struct.__init__, .{ .name = "codegenstruct___init__" });
                } else if (std.mem.eql(u8, decl.name, "__del__")) {
                    @export(zig_struct.__del__, .{ .name = "codegenstruct___del__" });
                } else {
                    const field = @field(zig_struct, decl.name);
                    @export(field, .{ .name = "codegenstruct_" ++ decl.name });
                }
            }
        },
        else => @compileError("exportStruct only works with structs"),
    }
}
